// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/weaveworks/eksctl/pkg/utils/kubectl"
)

type FakeKubernetesClient struct {
	AppendArgForNextCmdStub        func(string)
	appendArgForNextCmdMutex       sync.RWMutex
	appendArgForNextCmdArgsForCall []struct {
		arg1 string
	}
	CheckKubectlVersionStub        func() error
	checkKubectlVersionMutex       sync.RWMutex
	checkKubectlVersionArgsForCall []struct {
	}
	checkKubectlVersionReturns struct {
		result1 error
	}
	checkKubectlVersionReturnsOnCall map[int]struct {
		result1 error
	}
	FmtCmdStub        func([]string) string
	fmtCmdMutex       sync.RWMutex
	fmtCmdArgsForCall []struct {
		arg1 []string
	}
	fmtCmdReturns struct {
		result1 string
	}
	fmtCmdReturnsOnCall map[int]struct {
		result1 string
	}
	GetClientVersionStub        func() (string, error)
	getClientVersionMutex       sync.RWMutex
	getClientVersionArgsForCall []struct {
	}
	getClientVersionReturns struct {
		result1 string
		result2 error
	}
	getClientVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetServerVersionStub        func() (string, error)
	getServerVersionMutex       sync.RWMutex
	getServerVersionArgsForCall []struct {
	}
	getServerVersionReturns struct {
		result1 string
		result2 error
	}
	getServerVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetEnvStub        func([]string)
	setEnvMutex       sync.RWMutex
	setEnvArgsForCall []struct {
		arg1 []string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKubernetesClient) AppendArgForNextCmd(arg1 string) {
	fake.appendArgForNextCmdMutex.Lock()
	fake.appendArgForNextCmdArgsForCall = append(fake.appendArgForNextCmdArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppendArgForNextCmdStub
	fake.recordInvocation("AppendArgForNextCmd", []interface{}{arg1})
	fake.appendArgForNextCmdMutex.Unlock()
	if stub != nil {
		fake.AppendArgForNextCmdStub(arg1)
	}
}

func (fake *FakeKubernetesClient) AppendArgForNextCmdCallCount() int {
	fake.appendArgForNextCmdMutex.RLock()
	defer fake.appendArgForNextCmdMutex.RUnlock()
	return len(fake.appendArgForNextCmdArgsForCall)
}

func (fake *FakeKubernetesClient) AppendArgForNextCmdCalls(stub func(string)) {
	fake.appendArgForNextCmdMutex.Lock()
	defer fake.appendArgForNextCmdMutex.Unlock()
	fake.AppendArgForNextCmdStub = stub
}

func (fake *FakeKubernetesClient) AppendArgForNextCmdArgsForCall(i int) string {
	fake.appendArgForNextCmdMutex.RLock()
	defer fake.appendArgForNextCmdMutex.RUnlock()
	argsForCall := fake.appendArgForNextCmdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKubernetesClient) CheckKubectlVersion() error {
	fake.checkKubectlVersionMutex.Lock()
	ret, specificReturn := fake.checkKubectlVersionReturnsOnCall[len(fake.checkKubectlVersionArgsForCall)]
	fake.checkKubectlVersionArgsForCall = append(fake.checkKubectlVersionArgsForCall, struct {
	}{})
	stub := fake.CheckKubectlVersionStub
	fakeReturns := fake.checkKubectlVersionReturns
	fake.recordInvocation("CheckKubectlVersion", []interface{}{})
	fake.checkKubectlVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKubernetesClient) CheckKubectlVersionCallCount() int {
	fake.checkKubectlVersionMutex.RLock()
	defer fake.checkKubectlVersionMutex.RUnlock()
	return len(fake.checkKubectlVersionArgsForCall)
}

func (fake *FakeKubernetesClient) CheckKubectlVersionCalls(stub func() error) {
	fake.checkKubectlVersionMutex.Lock()
	defer fake.checkKubectlVersionMutex.Unlock()
	fake.CheckKubectlVersionStub = stub
}

func (fake *FakeKubernetesClient) CheckKubectlVersionReturns(result1 error) {
	fake.checkKubectlVersionMutex.Lock()
	defer fake.checkKubectlVersionMutex.Unlock()
	fake.CheckKubectlVersionStub = nil
	fake.checkKubectlVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKubernetesClient) CheckKubectlVersionReturnsOnCall(i int, result1 error) {
	fake.checkKubectlVersionMutex.Lock()
	defer fake.checkKubectlVersionMutex.Unlock()
	fake.CheckKubectlVersionStub = nil
	if fake.checkKubectlVersionReturnsOnCall == nil {
		fake.checkKubectlVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkKubectlVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKubernetesClient) FmtCmd(arg1 []string) string {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.fmtCmdMutex.Lock()
	ret, specificReturn := fake.fmtCmdReturnsOnCall[len(fake.fmtCmdArgsForCall)]
	fake.fmtCmdArgsForCall = append(fake.fmtCmdArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.FmtCmdStub
	fakeReturns := fake.fmtCmdReturns
	fake.recordInvocation("FmtCmd", []interface{}{arg1Copy})
	fake.fmtCmdMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKubernetesClient) FmtCmdCallCount() int {
	fake.fmtCmdMutex.RLock()
	defer fake.fmtCmdMutex.RUnlock()
	return len(fake.fmtCmdArgsForCall)
}

func (fake *FakeKubernetesClient) FmtCmdCalls(stub func([]string) string) {
	fake.fmtCmdMutex.Lock()
	defer fake.fmtCmdMutex.Unlock()
	fake.FmtCmdStub = stub
}

func (fake *FakeKubernetesClient) FmtCmdArgsForCall(i int) []string {
	fake.fmtCmdMutex.RLock()
	defer fake.fmtCmdMutex.RUnlock()
	argsForCall := fake.fmtCmdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKubernetesClient) FmtCmdReturns(result1 string) {
	fake.fmtCmdMutex.Lock()
	defer fake.fmtCmdMutex.Unlock()
	fake.FmtCmdStub = nil
	fake.fmtCmdReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKubernetesClient) FmtCmdReturnsOnCall(i int, result1 string) {
	fake.fmtCmdMutex.Lock()
	defer fake.fmtCmdMutex.Unlock()
	fake.FmtCmdStub = nil
	if fake.fmtCmdReturnsOnCall == nil {
		fake.fmtCmdReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.fmtCmdReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKubernetesClient) GetClientVersion() (string, error) {
	fake.getClientVersionMutex.Lock()
	ret, specificReturn := fake.getClientVersionReturnsOnCall[len(fake.getClientVersionArgsForCall)]
	fake.getClientVersionArgsForCall = append(fake.getClientVersionArgsForCall, struct {
	}{})
	stub := fake.GetClientVersionStub
	fakeReturns := fake.getClientVersionReturns
	fake.recordInvocation("GetClientVersion", []interface{}{})
	fake.getClientVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKubernetesClient) GetClientVersionCallCount() int {
	fake.getClientVersionMutex.RLock()
	defer fake.getClientVersionMutex.RUnlock()
	return len(fake.getClientVersionArgsForCall)
}

func (fake *FakeKubernetesClient) GetClientVersionCalls(stub func() (string, error)) {
	fake.getClientVersionMutex.Lock()
	defer fake.getClientVersionMutex.Unlock()
	fake.GetClientVersionStub = stub
}

func (fake *FakeKubernetesClient) GetClientVersionReturns(result1 string, result2 error) {
	fake.getClientVersionMutex.Lock()
	defer fake.getClientVersionMutex.Unlock()
	fake.GetClientVersionStub = nil
	fake.getClientVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeKubernetesClient) GetClientVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.getClientVersionMutex.Lock()
	defer fake.getClientVersionMutex.Unlock()
	fake.GetClientVersionStub = nil
	if fake.getClientVersionReturnsOnCall == nil {
		fake.getClientVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getClientVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeKubernetesClient) GetServerVersion() (string, error) {
	fake.getServerVersionMutex.Lock()
	ret, specificReturn := fake.getServerVersionReturnsOnCall[len(fake.getServerVersionArgsForCall)]
	fake.getServerVersionArgsForCall = append(fake.getServerVersionArgsForCall, struct {
	}{})
	stub := fake.GetServerVersionStub
	fakeReturns := fake.getServerVersionReturns
	fake.recordInvocation("GetServerVersion", []interface{}{})
	fake.getServerVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKubernetesClient) GetServerVersionCallCount() int {
	fake.getServerVersionMutex.RLock()
	defer fake.getServerVersionMutex.RUnlock()
	return len(fake.getServerVersionArgsForCall)
}

func (fake *FakeKubernetesClient) GetServerVersionCalls(stub func() (string, error)) {
	fake.getServerVersionMutex.Lock()
	defer fake.getServerVersionMutex.Unlock()
	fake.GetServerVersionStub = stub
}

func (fake *FakeKubernetesClient) GetServerVersionReturns(result1 string, result2 error) {
	fake.getServerVersionMutex.Lock()
	defer fake.getServerVersionMutex.Unlock()
	fake.GetServerVersionStub = nil
	fake.getServerVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeKubernetesClient) GetServerVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.getServerVersionMutex.Lock()
	defer fake.getServerVersionMutex.Unlock()
	fake.GetServerVersionStub = nil
	if fake.getServerVersionReturnsOnCall == nil {
		fake.getServerVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getServerVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeKubernetesClient) SetEnv(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setEnvMutex.Lock()
	fake.setEnvArgsForCall = append(fake.setEnvArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SetEnvStub
	fake.recordInvocation("SetEnv", []interface{}{arg1Copy})
	fake.setEnvMutex.Unlock()
	if stub != nil {
		fake.SetEnvStub(arg1)
	}
}

func (fake *FakeKubernetesClient) SetEnvCallCount() int {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	return len(fake.setEnvArgsForCall)
}

func (fake *FakeKubernetesClient) SetEnvCalls(stub func([]string)) {
	fake.setEnvMutex.Lock()
	defer fake.setEnvMutex.Unlock()
	fake.SetEnvStub = stub
}

func (fake *FakeKubernetesClient) SetEnvArgsForCall(i int) []string {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	argsForCall := fake.setEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKubernetesClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appendArgForNextCmdMutex.RLock()
	defer fake.appendArgForNextCmdMutex.RUnlock()
	fake.checkKubectlVersionMutex.RLock()
	defer fake.checkKubectlVersionMutex.RUnlock()
	fake.fmtCmdMutex.RLock()
	defer fake.fmtCmdMutex.RUnlock()
	fake.getClientVersionMutex.RLock()
	defer fake.getClientVersionMutex.RUnlock()
	fake.getServerVersionMutex.RLock()
	defer fake.getServerVersionMutex.RUnlock()
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKubernetesClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kubectl.KubernetesClient = new(FakeKubernetesClient)
